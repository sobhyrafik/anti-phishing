<?php

namespace App\Http\Controllers;

use App\Jobs\ScanFileJob;
use App\Services\VirusTotalService;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\RateLimiter;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\Queue;
use Illuminate\Support\Str;
use Inertia\Inertia;

class MalwareDetectionController extends Controller
{
    protected $virusTotalService;
    protected $maxFileSize = 32 * 1024 * 1024; // 32MB (VirusTotal's limit)
    
    public function __construct(VirusTotalService $virusTotalService)
    {
        $this->virusTotalService = $virusTotalService;
    }
    
    public function show()
    {
        return Inertia::render('MalwareDetection/MalwareDetection');
    }
    
    public function scanFile(Request $request)
    {
        // Validate based on whether hash or file is provided
        if ($request->has('hash')) {
            $request->validate([
                'hash' => 'required|string|size:64', // SHA-256 hash is 64 characters
                'fileName' => 'required|string|max:255',
                'fileSize' => 'required|integer|min:0',
            ]);
        } else {
            $request->validate([
                'file' => 'required|file|max:32000', // 32MB max (VirusTotal's limit)
            ]);
        }
        
        $userId = $request->user() ? $request->user()->id : $request->ip();
        
        // Implement rate limiting - 5 scans per minute per user
        if (RateLimiter::tooManyAttempts('file-scan:'.$userId, 5)) {
            $seconds = RateLimiter::availableIn('file-scan:'.$userId);
            
            return response()->json([
                'success' => false,
                'message' => "Rate limit exceeded. Please try again after {$seconds} seconds.",
            ], 429);
        }
        
        RateLimiter::hit('file-scan:'.$userId);
        
        try {
            // Generate a unique job ID
            $jobId = (string) Str::uuid();
            
            // Handle hash-based scanning
            if ($request->has('hash')) {
                $fileHash = $request->input('hash');
                $fileName = $request->input('fileName');
                $fileSize = $request->input('fileSize');
                
                // Check cache first using file hash
                $cacheKey = 'file-scan:' . $fileHash;
                $cachedResults = $this->virusTotalService->getCachedResults($cacheKey);
                
                if ($cachedResults) {
                    return response()->json([
                        'success' => true,
                        'fileName' => $fileName,
                        'fileSize' => $fileSize,
                        'jobId' => $jobId,
                        'results' => $cachedResults,
                        'fromCache' => true,
                        'completed' => true
                    ]);
                }
                
                // Create initial status
                Cache::put('scan-status:' . $jobId, [
                    'status' => 'queued',
                    'progress' => 0,
                    'message' => 'Hash analysis queued, starting soon',
                    'fileName' => $fileName,
                    'fileSize' => $fileSize
                ], 3600);
                
                // Dispatch the job with just the hash
                ScanFileJob::dispatch(
                    null,          // No file path
                    $fileName,     // Original file name
                    $fileHash,     // File hash
                    $fileSize,     // File size
                    $userId,       // User ID
                    $jobId,        // Job ID
                    false,         // Don't delete after scan (no file stored)
                    'hash_only'    // Hash-only mode
                );
                
                return response()->json([
                    'success' => true,
                    'message' => 'Hash analysis queued',
                    'jobId' => $jobId,
                    'fileName' => $fileName,
                    'fileSize' => $fileSize,
                    'completed' => false
                ]);
            }
            
            // Handle file-based scanning
            // Check if the file is actually present in the request
            if (!$request->hasFile('file') || !$request->file('file')->isValid()) {
                return response()->json([
                    'success' => false, 
                    'message' => 'No valid file was uploaded. Please select a file or use hash scanning mode.'
                ], 400);
            }

            $file = $request->file('file');
            $fileName = $file->getClientOriginalName();
            $fileSize = $file->getSize();
            $fileHash = hash_file('sha256', $file->getRealPath());
            
            // Check cache first using file hash
            $cacheKey = 'file-scan:' . $fileHash;
            $cachedResults = $this->virusTotalService->getCachedResults($cacheKey);
            
            if ($cachedResults) {
                return response()->json([
                    'success' => true,
                    'fileName' => $fileName,
                    'fileSize' => $fileSize,
                    'jobId' => $jobId,
                    'results' => $cachedResults,
                    'fromCache' => true,
                    'completed' => true
                ]);
            }
            
            // For files smaller than the max size, use queue
            if ($fileSize <= $this->maxFileSize) {
                try {
                    // Create a dedicated disk for malware scans
                    $disk = 'local';
                    $storagePath = 'malware-scans';
                    $fullPath = storage_path('app/' . $storagePath);
                    
                    // Make sure the directory exists
                    if (!is_dir($fullPath)) {
                        mkdir($fullPath, 0777, true);
                        Log::info("Created storage directory: {$fullPath}");
                    }
                    
                    // Generate a simple filename that won't have special characters
                    $tempFileName = time() . '_' . Str::random(8) . '.bin';
                    $relativePath = $storagePath . '/' . $tempFileName;
                    $filePath = storage_path('app/' . $relativePath);
                    
                    // Get the uploaded file contents
                    $fileContent = file_get_contents($file->getRealPath());
                    
                    // Store the file directly using file_put_contents
                    if (file_put_contents($filePath, $fileContent) === false) {
                        Log::error("Failed to write file to path: {$filePath}");
                        throw new \Exception("Failed to store file at path: {$filePath}");
                    }
                    
                    // Double-check file exists after writing
                    if (!file_exists($filePath)) {
                        Log::error("File does not exist after writing: {$filePath}");
                        throw new \Exception("File not found after writing to path: {$filePath}");
                    }
                    
                    $actualSize = filesize($filePath);
                    if ($actualSize <= 0) {
                        Log::error("File is empty after writing: {$filePath}");
                        throw new \Exception("File exists but is empty at path: {$filePath}");
                    }
                    
                    // Log file information for debugging
                    Log::info('File stored successfully for scanning', [
                        'filePath' => $filePath,
                        'relativePath' => $relativePath,
                        'disk' => $disk,
                        'jobId' => $jobId,
                        'exists' => file_exists($filePath) ? 'yes' : 'no',
                        'size' => $actualSize
                    ]);
                    
                    // Create initial status
                    Cache::put('scan-status:' . $jobId, [
                        'status' => 'queued',
                        'progress' => 0,
                        'message' => 'File analysis queued, starting soon',
                        'fileName' => $fileName,
                        'fileSize' => $fileSize
                    ], 3600);
                    
                    // Dispatch the job with the absolute file path for simplicity
                    ScanFileJob::dispatch(
                        $filePath,     // Absolute file path
                        $fileName,     // Original file name
                        $fileHash,     // File hash
                        $fileSize,     // File size
                        $userId,       // User ID
                        $jobId,        // Job ID
                        true,          // Delete after scan
                        'file'         // File mode
                    );
                    
                    return response()->json([
                        'success' => true,
                        'message' => 'File analysis queued',
                        'jobId' => $jobId,
                        'fileName' => $fileName,
                        'fileSize' => $fileSize,
                        'completed' => false
                    ]);
                } catch (\Exception $e) {
                    Log::error('Error preparing file for scan', [
                        'error' => $e->getMessage(),
                        'trace' => $e->getTraceAsString(),
                        'fileName' => $fileName,
                        'jobId' => $jobId
                    ]);
                    
                    throw $e;
                }
            } else {
                // For larger files, inform user of size limitations
                return response()->json([
                    'success' => false,
                    'message' => 'File size exceeds the maximum limit of 32MB for scanning.'
                ], 400);
            }
            
        } catch (\Exception $e) {
            Log::error('Error in file scan', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);
            
            return response()->json([
                'success' => false,
                'message' => 'An error occurred while scanning the file',
                'error' => $e->getMessage()
            ], 500);
        }
    }
    
    /**
     * Check the status of a scan job
     */
    public function checkStatus(Request $request)
    {
        $request->validate([
            'jobId' => 'required|string'
        ]);
        
        $jobId = $request->input('jobId');
        $statusKey = 'scan-status:' . $jobId;
        
        if (!Cache::has($statusKey)) {
            return response()->json([
                'success' => false,
                'message' => 'Job not found or expired'
            ], 404);
        }
        
        $status = Cache::get($statusKey);
        $completed = in_array($status['status'] ?? '', ['completed', 'failed', 'cancelled']);
        
        return response()->json([
            'success' => true,
            'completed' => $completed,
            'status' => $status
        ]);
    }
    
    /**
     * Cancel an in-progress scan job
     */
    public function cancelJob(Request $request)
    {
        $request->validate([
            'jobId' => 'required|string'
        ]);
        
        $jobId = $request->input('jobId');
        $statusKey = 'scan-status:' . $jobId;
        
        if (!Cache::has($statusKey)) {
            return response()->json([
                'success' => false,
                'message' => 'Job not found or expired'
            ], 404);
        }
        
        $status = Cache::get($statusKey);
        
        // Check if job is already completed or failed
        if (in_array($status['status'] ?? '', ['completed', 'failed'])) {
            return response()->json([
                'success' => false,
                'message' => 'Job has already completed or failed and cannot be cancelled'
            ], 400);
        }
        
        // Update job status to cancelled
        $updatedStatus = array_merge($status, [
            'status' => 'cancelled',
            'progress' => 100,
            'message' => 'Scan cancelled by user'
        ]);
        
        Cache::put($statusKey, $updatedStatus, 3600);
        
        // Note: we can't actually stop a queue job that's already running,
        // but we can mark it as cancelled and the job can check this status
        // to stop processing early
        
        return response()->json([
            'success' => true,
            'message' => 'Scan job has been cancelled',
            'completed' => true,
            'status' => $updatedStatus
        ]);
    }
    
    /**
     * Test the VirusTotal API connection
     * 
     * @return \Illuminate\Http\JsonResponse
     */
    public function testApiConnection()
    {
        try {
            $apiStatus = $this->virusTotalService->testApiConnection();
            
            if ($apiStatus) {
                return response()->json([
                    'success' => true,
                    'message' => 'VirusTotal API connection is working properly.'
                ]);
            } else {
                return response()->json([
                    'success' => false,
                    'message' => 'VirusTotal API connection test failed. The API key may be invalid or rate limited.'
                ], 400);
            }
        } catch (\Exception $e) {
            Log::error('Error testing API connection', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);
            
            return response()->json([
                'success' => false,
                'message' => 'An error occurred while testing the API connection: ' . $e->getMessage()
            ], 500);
        }
    }
} 