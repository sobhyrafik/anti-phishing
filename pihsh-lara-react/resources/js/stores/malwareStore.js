import { create } from 'zustand';
import axios from 'axios';

const useMalwareStore = create((set, get) => ({
  // Scan state
  file: null,
  dragging: false,
  loading: false,
  result: null,
  scanData: null,
  fromCache: false,
  scanTime: null,
  fileName: '',
  fileSize: 0,
  jobId: null,
  progress: 0,
  statusMessage: '',
  cancelling: false,
  scanMode: 'file', // 'file' or 'hash'
  fileHash: '',
  statusCheckInterval: null,
  
  // Actions
  setDragging: (value) => set({ dragging: value }),
  setScanMode: (mode) => {
    if (mode === get().scanMode) return;
    
    // Clear previous data when toggling
    set({
      file: null,
      fileName: '',
      fileSize: 0,
      fileHash: '',
      result: null,
      scanData: null,
      scanMode: mode
    });
  },
  setFileHash: (hash) => set({ fileHash: hash }),
  
  // Process file
  processFile: (selectedFile) => {
    set({
      file: selectedFile,
      fileName: selectedFile.name,
      fileSize: selectedFile.size,
      fileHash: '' // Clear hash when a file is selected
    });
  },
  
  // Handle file change
  handleFileChange: (e) => {
    set({ scanMode: 'file' });
    const selectedFile = e.target.files[0];
    if (selectedFile) {
      get().processFile(selectedFile);
    }
  },
  
  // Handle drag over
  handleDragOver: (e) => {
    e.preventDefault();
    set({ dragging: true });
  },
  
  // Handle drag leave
  handleDragLeave: (e) => {
    e.preventDefault();
    set({ dragging: false });
  },
  
  // Handle drop
  handleDrop: (e) => {
    e.preventDefault();
    set({ dragging: false, scanMode: 'file' });
    
    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
      get().processFile(e.dataTransfer.files[0]);
    }
  },
  
  // Validate hash
  validateHash: (hash) => {
    // Check if it's a valid SHA-256 hash (64 hex characters)
    return /^[a-fA-F0-9]{64}$/.test(hash);
  },
  
  // Handle scan
  handleScan: async () => {
    const { scanMode, file, fileHash, validateHash } = get();
    
    if (scanMode === 'file') {
      if (!file) {
        set({
          result: {
            status: 'error',
            message: 'Please select a file to scan.'
          }
        });
        return;
      }
    } else {
      // Hash mode validation
      if (!fileHash) {
        set({
          result: {
            status: 'error',
            message: 'Please enter a file hash.'
          }
        });
        return;
      }
      
      if (!validateHash(fileHash)) {
        set({
          result: {
            status: 'error',
            message: 'Please enter a valid SHA-256 hash (64 hex characters).'
          }
        });
        return;
      }
    }
    
    set({
      loading: true,
      result: null,
      scanData: null,
      fromCache: false,
      progress: 0,
      statusMessage: ''
    });
    
    // Clear any existing interval
    const { statusCheckInterval } = get();
    if (statusCheckInterval) {
      clearInterval(statusCheckInterval);
      set({ statusCheckInterval: null });
    }
    
    const startTime = performance.now();
    
    try {
      let response;
      
      if (scanMode === 'file') {
        const formData = new FormData();
        formData.append('file', file);
        
        response = await axios.post('/malware-scan', formData, {
          headers: {
            'Content-Type': 'multipart/form-data',
          }
        });
      } else {
        // Hash mode
        response = await axios.post('/malware-scan', {
          hash: fileHash,
          fileName: 'Hash Scan: ' + fileHash.substring(0, 16) + '...',
          fileSize: 0
        });
      }
      
      if (response.data.success) {
        // If the results are immediately available (from cache)
        if (response.data.completed) {
          const endTime = performance.now();
          const timeElapsed = ((endTime - startTime) / 1000).toFixed(2);
          
          const scanResults = response.data.results;
          set({
            scanTime: timeElapsed,
            scanData: scanResults,
            fromCache: response.data.fromCache || false,
            loading: false
          });
          
          // Determine if file is safe based on scan results
          get().handleScanResults(scanResults);
        } else {
          // Job was queued, start polling for status
          set({
            jobId: response.data.jobId,
            statusMessage: 'Analysis queued, starting soon...',
            progress: 5
          });
          
          // Start polling for job status
          const intervalId = setInterval(() => {
            get().checkJobStatus(response.data.jobId, startTime);
          }, 2000); // Check every 2 seconds
          
          set({ statusCheckInterval: intervalId });
        }
      } else {
        set({
          result: {
            status: 'error',
            message: response.data.message || 'Failed to scan file. Please try again later.'
          },
          loading: false
        });
      }
    } catch (error) {
      console.error('File scan error:', error);
      
      let errorMessage = 'An error occurred while scanning the file.';
      
      if (error.response?.status === 429) {
        errorMessage = 'Rate limit exceeded. Please try again in a few moments.';
      } else if (error.response?.status === 413) {
        errorMessage = 'File is too large. Maximum file size is 32MB.';
      } else if (error.response?.data?.message) {
        const message = error.response.data.message;
        if (message.includes('File does not exist') || message.includes('file not found')) {
          errorMessage = 'System error: File could not be found for scanning. Please try again or contact support if the issue persists.';
        } else {
          errorMessage = message;
        }
      }
      
      set({
        result: {
          status: 'error',
          message: errorMessage
        },
        loading: false
      });
    }
  },
  
  // Check job status
  checkJobStatus: async (jobId, startTime) => {
    try {
      const response = await axios.post('/malware-status', { jobId });
      
      if (response.data.success) {
        const status = response.data.status;
        
        // Update progress
        set({
          progress: status.progress || 0,
          statusMessage: status.message || 'Processing file...'
        });
        
        if (response.data.completed) {
          // Stop polling
          const { statusCheckInterval } = get();
          if (statusCheckInterval) {
            clearInterval(statusCheckInterval);
            set({ statusCheckInterval: null });
          }
          
          const endTime = performance.now();
          const timeElapsed = ((endTime - startTime) / 1000).toFixed(2);
          set({ scanTime: timeElapsed });
          
          // Handle completed status
          if (status.status === 'completed') {
            set({
              fromCache: status.fromCache || false,
              scanData: status.results,
              loading: false
            });
            get().handleScanResults(status.results);
          } else if (status.status === 'cancelled') {
            // Handle cancelled status
            set({
              result: {
                status: 'warning',
                message: 'Scan was cancelled by user.'
              },
              loading: false
            });
          } else {
            // Failed
            set({
              result: {
                status: 'error',
                message: status.message || 'Scan failed. Please try again.'
              },
              loading: false
            });
          }
        }
      } else {
        // Error getting status
        const { statusCheckInterval } = get();
        if (statusCheckInterval) {
          clearInterval(statusCheckInterval);
          set({ statusCheckInterval: null });
        }
        
        set({
          result: {
            status: 'error',
            message: 'Failed to get scan status. Please try again.'
          },
          loading: false
        });
      }
    } catch (error) {
      console.error('Status check error:', error);
      
      // Stop polling on error
      const { statusCheckInterval } = get();
      if (statusCheckInterval) {
        clearInterval(statusCheckInterval);
        set({ statusCheckInterval: null });
      }
      
      set({
        result: {
          status: 'error',
          message: 'Failed to check scan status. Please try again.'
        },
        loading: false
      });
    }
  },
  
  // Handle scan results
  handleScanResults: (scanResults) => {
    const maliciousEngines = scanResults.stats.malicious || 0;
    const suspiciousEngines = scanResults.stats.suspicious || 0;
    const harmlessEngines = scanResults.stats.harmless || 0;
    const undetectedEngines = scanResults.stats.undetected || 0;
    const totalEngines = Object.values(scanResults.stats).reduce((a, b) => a + b, 0);
    
    // Special handling for rate limit errors
    if (scanResults.rate_limited) {
      set({
        result: {
          status: 'error',
          message: 'VirusTotal API rate limit exceeded. Please try again in a few minutes.'
        }
      });
      return;
    }
    
    // Check for API error flag
    if (scanResults.api_error) {
      set({
        result: {
          status: 'error',
          message: scanResults.message || 'The VirusTotal API returned an error. The scan was not successful. Please check your API key.'
        }
      });
      return;
    }
    
    // If there are no results or all values are zero, show a warning
    if (totalEngines === 0 || scanResults.all_zero) {
      // Check if this is likely an API key issue
      if (scanResults.error && scanResults.error.includes('API key')) {
        set({
          result: {
            status: 'error',
            message: 'VirusTotal API key may be invalid. Please check your API key configuration in the .env file.'
          }
        });
      } else {
        set({
          result: {
            status: 'warning',
            message: 'No results were returned from the scan. This could be due to an error with the scanning service or the file/hash may not be recognized. Try again or try uploading the file instead of using a hash.'
          }
        });
      }
    }
    // If the file has malicious detections, it's unsafe
    else if (maliciousEngines > 0) {
      set({
        result: {
          status: 'unsafe',
          message: `Alert: Malware detected! ${maliciousEngines} out of ${totalEngines} security vendors flagged this file as malicious.`
        }
      });
    }
    // If the file has suspicious but no malicious detections, it's suspicious
    else if (suspiciousEngines > 0) {
      set({
        result: {
          status: 'warning',
          message: `Caution: ${suspiciousEngines} out of ${totalEngines} security vendors flagged this file as suspicious.`
        }
      });
    }
    // If status "not_found" in the results (hash-only scan without results)
    else if (scanResults.status === 'not_found') {
      set({
        result: {
          status: 'warning',
          message: `The file hash was not found in VirusTotal's database. Please upload the actual file for scanning.`
        }
      });
    }
    // Otherwise, if no malicious or suspicious flags, it's safe
    else {
      set({
        result: {
          status: 'safe',
          message: `This file appears to be safe. ${harmlessEngines} out of ${totalEngines} security vendors found this file harmless.`
        }
      });
    }
  },
  
  // Handle cancel
  handleCancel: async () => {
    const { jobId, loading } = get();
    if (!jobId || !loading) return;
    
    set({ cancelling: true });
    
    try {
      const response = await axios.post('/malware-cancel', { jobId });
      
      if (response.data.success) {
        // Stop polling
        const { statusCheckInterval } = get();
        if (statusCheckInterval) {
          clearInterval(statusCheckInterval);
          set({ statusCheckInterval: null });
        }
        
        set({
          statusMessage: 'Scan cancelled',
          result: {
            status: 'warning',
            message: 'Scan was cancelled by user.'
          },
          loading: false
        });
      } else {
        console.error('Failed to cancel scan:', response.data.message);
      }
    } catch (error) {
      console.error('Error cancelling scan:', error);
    } finally {
      set({ cancelling: false });
    }
  },
}));

export default useMalwareStore;